

{
  "quizTitle": "Operating Systems – Unit 3: Synchronization & Deadlocks",
  "category": "Operating Systems",
  "difficulty": "Medium-Hard",
  "createdAt": "2025-10-08T13:00:00Z",
  "questions": [
    {
      "questionId": 1,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which of the following is a necessary condition for a deadlock to occur?",
      "options": [
        "Preemptable resources only",
        "Circular wait",
        "Global scheduling",
        "Single-threaded execution"
      ],
      "correctAnswer": "Circular wait"
    },
    {
      "questionId": 2,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Peterson's algorithm provides a solution to the critical section problem for how many processes?",
      "options": [
        "Any number of processes",
        "Exactly two processes",
        "Three processes",
        "Only for kernel threads"
      ],
      "correctAnswer": "Exactly two processes"
    },
    {
      "questionId": 3,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which hardware instruction is commonly used to implement atomic test-and-set for mutual exclusion?",
      "options": [
        "compare-and-swap",
        "jump-if-zero",
        "load-effective-address",
        "floating-point multiply"
      ],
      "correctAnswer": "compare-and-swap"
    },
    {
      "questionId": 4,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "In the producer-consumer problem using semaphores, which semaphore tracks the number of full slots?",
      "options": [
        "mutex",
        "empty",
        "full",
        "ready"
      ],
      "correctAnswer": "full"
    },
    {
      "questionId": 5,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which synchronization primitive automatically wakes one waiting thread and releases the associated lock?",
      "options": [
        "Binary semaphore (P/V)",
        "Condition variable (signal)",
        "Spinlock",
        "Barrier"
      ],
      "correctAnswer": "Condition variable (signal)"
    },
    {
      "questionId": 6,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which of the following is TRUE about monitors?",
      "options": [
        "Monitors require explicit use of semaphores by the programmer",
        "Monitors combine mutual exclusion and condition variables in a single abstraction",
        "Monitors are only available in kernel code",
        "Monitors allow multiple threads inside the monitor without synchronization"
      ],
      "correctAnswer": "Monitors combine mutual exclusion and condition variables in a single abstraction"
    },
    {
      "questionId": 7,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which classic problem illustrates both deadlock and starvation when implemented poorly?",
      "options": [
        "Producer-Consumer",
        "Dining Philosophers",
        "Readers-Writers (first variant)",
        "Banker’s Algorithm"
      ],
      "correctAnswer": "Dining Philosophers"
    },
    {
      "questionId": 8,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "In the context of deadlock handling, what does the 'No preemption' condition imply?",
      "options": [
        "A resource can be forcibly taken from a process",
        "Resources cannot be reclaimed until released voluntarily",
        "Processes cannot request additional resources",
        "Resources are always sharable"
      ],
      "correctAnswer": "Resources cannot be reclaimed until released voluntarily"
    },
    {
      "questionId": 9,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "The Banker's algorithm is primarily used for which deadlock strategy?",
      "options": [
        "Prevention",
        "Avoidance",
        "Detection",
        "Recovery"
      ],
      "correctAnswer": "Avoidance"
    },
    {
      "questionId": 10,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which data structure is used to detect deadlocks by representing resource allocation and requests?",
      "options": [
        "Wait-for graph",
        "Ready queue",
        "Page table",
        "Priority heap"
      ],
      "correctAnswer": "Wait-for graph"
    },
    {
      "questionId": 11,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which of the following changes would help prevent deadlock by breaking the 'hold-and-wait' condition?",
      "options": [
        "Require processes to request all required resources at once",
        "Increase resource shareability",
        "Allow preemption of CPU",
        "Use round-robin scheduling"
      ],
      "correctAnswer": "Require processes to request all required resources at once"
    },
    {
      "questionId": 12,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "In semaphore terminology, what is the correct sequence of operations for entering and exiting a critical section?",
      "options": [
        "signal(P); critical section; wait(V)",
        "wait(P); critical section; signal(V)",
        "P(); critical section; P()",
        "V(); critical section; V()"
      ],
      "correctAnswer": "wait(P); critical section; signal(V)"
    },
    {
      "questionId": 13,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which of the following is a disadvantage of busy-waiting (spinlocks)?",
      "options": [
        "Lower latency on single-CPU systems",
        "Consumes CPU cycles while waiting",
        "Prevents deadlock automatically",
        "Eliminates context switches entirely"
      ],
      "correctAnswer": "Consumes CPU cycles while waiting"
    },
    {
      "questionId": 14,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which method is commonly used to recover from a detected deadlock when aborting processes?",
      "options": [
        "Rollback all processes to start",
        "Abort one or more processes to break the cycle",
        "Increase available resource instances",
        "Convert resources to preemptable ones automatically"
      ],
      "correctAnswer": "Abort one or more processes to break the cycle"
    },
    {
      "questionId": 15,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which property ensures that each process will eventually enter the critical section (no indefinite postponement)?",
      "options": [
        "Mutual exclusion",
        "Progress",
        "Bounded waiting",
        "Deadlock freedom"
      ],
      "correctAnswer": "Bounded waiting"
    },
    {
      "questionId": 16,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "What is the main difference between counting semaphore and binary semaphore?",
      "options": [
        "Counting semaphore is only for one process, binary for many",
        "Binary semaphore can have values greater than 1, counting is 0 or 1",
        "Counting semaphore can represent multiple units of a resource, binary represents a single lock",
        "Binary semaphores do not provide mutual exclusion"
      ],
      "correctAnswer": "Counting semaphore can represent multiple units of a resource, binary represents a single lock"
    },
    {
      "questionId": 17,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which algorithm guarantees freedom from deadlock without preemption if resource maximum demands are known in advance?",
      "options": [
        "Peterson's algorithm",
        "Banker's algorithm",
        "Dijkstra’s shortest path",
        "Lamport’s logical clocks"
      ],
      "correctAnswer": "Banker's algorithm"
    },
    {
      "questionId": 18,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "If a system uses a wait-for graph and finds a cycle, this indicates:",
      "options": [
        "The system is in a safe state",
        "There is a deadlock among the processes in the cycle",
        "All processes are blocked but not deadlocked",
        "Resources are underutilized"
      ],
      "correctAnswer": "There is a deadlock among the processes in the cycle"
    },
    {
      "questionId": 19,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which of the following is an example of a software-only solution to mutual exclusion?",
      "options": [
        "Test-and-set lock",
        "Peterson's algorithm",
        "Hardware interrupt disabling",
        "Atomic compare-and-swap instruction"
      ],
      "correctAnswer": "Peterson's algorithm"
    },
    {
      "questionId": 20,
      "unit": "Unit 3: Synchronization & Deadlocks",
      "questionText": "Which recovery technique from deadlock attempts to preserve partial work by returning processes to previous states?",
      "options": [
        "Resource preemption without rollback",
        "Process termination without checkpointing",
        "Rollback to a safe checkpoint and restart",
        "Increasing process priorities"
      ],
      "correctAnswer": "Rollback to a safe checkpoint and restart"
    }
  ]
}